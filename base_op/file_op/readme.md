# 文件操作
操作系统将硬件封装成接口，给用户/应用程序使用。文件就是一种虚拟的接口，应用程序通过操作文件来将数据永久保留在硬盘中。
```
open函数模型
open(file, mode='rt', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```
**mode含义**
|字符串|含义|
|-|-|
|r|以读的方式打开，若文件，则报错|
|w|以写的方式打开，会先清空文件，若无文件，则创建|
|x|创建一个新文件，以写的方式打开，若文件已存在，则报错|
|a|以写的方式打开文件，若文件已存在，则在文件末尾追加内容|
|b|以二进制方式打开，可以和读写命令共用|
|t|以文本方式打开（默认）|
|+|以读和写的方式打开文件，用于更新文件|
|U|通用的换行模式（弃用）|

python区分二进制方式和文本方式
+ 以二进制打开文件，返回一个未解码的字节对象
+ 以文本方式打开，返回按系统默认编码或encoding指定的编码来解码的字符串对象

buffering
+ buffering=0，关闭缓冲区（仅在二进制方式打开时可用）
+ buffering=1，开启行缓冲区（仅在文本方式下生效）
+ buffering>1，其值代表固定大小的块缓冲区大小
+ buffering默认，二进制文件使用固定大小的块缓冲区，文本文件使用行缓冲区

**资源释放**
打开一个文件包含两部分资源：操作系统级打开文件+应用程序变量
+ f.close(),回收操作系统打开的文件
+ del f，回收应用程序级的变量

> `del f`需要在`f.close()`之后，否则会导致操作系统打开的文件没有关闭，Python的垃圾回收机制决定了我们无需执行`del f`。

为了方便我们能及时释放系统资源，在此我们使用`with`关键字来帮助我们进行上下文管理
```
with open("a.txt", 'w') as f:
	f.write("hello world")
```
**常见的文件操作方法**

|方法|功能|
|-|-|
|f.read()|读取所有文件，光标移动到文件末尾|
|f.readline()|读取每一行内容，光标移动到第二行首部|
|f.readlines()|读取每一行内容，存放于列表中|
|f.write("111\n222\n")|针对文本模式的写，需要自己写换行符|
|f.write("111\n222\n".encode('utf8'))|针对b模式的写，需要自己写换行符，并且编码|
|f.writelines(['333\n', '444\n'])|文件模式|
|f.writelines([bytes('333\n', encoding='utf8'), '444\n'.encode('utf8')])|二进制模式|
|f.readable()|文件是否可读|
|f.writeable()|文件是否可写|
|f.closed|文件是否关闭|
|f.encoding|如果文件打开为二进制方式，则没有该属性|
|f.flush()|立刻将文件内容从内存刷新到硬盘|

1. 通过read方式传输参数，如read(3)，当文件打开方式为文本模式，代表读取3个字符，当文件打开方式为二进制模式时，代表读取3个字节
2. 以字节为单位定位，seek、tell等方法。f.tell()返回文件对象当前所处的位置
